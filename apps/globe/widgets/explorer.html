<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body { margin: 0; padding: 0; background: #0a0a1a; }
    body.widget-fullscreen { height: 100%; }
    #globe-container { position: relative; width: 100%; height: 450px; }
    body.widget-fullscreen #globe-container { width: 100%; height: 100%; }
    #info { position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); color: #fff; font-family: system-ui; font-size: 18px; text-align: center; text-shadow: 0 2px 8px rgba(0,0,0,0.9); }
    #weather { position: absolute; top: 12px; left: 12px; color: #fff; font-family: system-ui; font-size: 14px; background: rgba(0,0,0,0.5); padding: 8px 12px; border-radius: 8px; min-width: 120px; }
    #weather .temp { font-size: 28px; font-weight: bold; }
    #weather .icon { font-size: 24px; margin-right: 4px; }
    #weather .desc { opacity: 0.8; font-size: 12px; }
    .btn { position: absolute; top: 12px; background: rgba(255,255,255,0.15); border: none; color: #fff; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-family: system-ui; font-size: 14px; }
    .btn:hover { background: rgba(255,255,255,0.25); }
    #reset { right: 12px; }
  </style>
</head>
<body>
  <div id="globe-container">
    <div id="weather"></div>
    <button id="reset" class="btn">↑ North</button>
    <div id="info"></div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Detect layout mode via CSS variable (set before JS runs)
    const isFullscreen = getComputedStyle(document.documentElement).getPropertyValue('--widget-layout').trim() === 'fullscreen';

    const countries = [
      { name: "United States", capital: "Washington D.C.", lat: 38.9, lon: -77.0 },
      { name: "United Kingdom", capital: "London", lat: 51.5, lon: -0.1 },
      { name: "France", capital: "Paris", lat: 48.9, lon: 2.3 },
      { name: "Germany", capital: "Berlin", lat: 52.5, lon: 13.4 },
      { name: "Japan", capital: "Tokyo", lat: 35.7, lon: 139.7 },
      { name: "Australia", capital: "Canberra", lat: -35.3, lon: 149.1 },
      { name: "Brazil", capital: "Brasilia", lat: -15.8, lon: -47.9 },
      { name: "India", capital: "New Delhi", lat: 28.6, lon: 77.2 },
      { name: "China", capital: "Beijing", lat: 39.9, lon: 116.4 },
      { name: "Russia", capital: "Moscow", lat: 55.8, lon: 37.6 },
      { name: "Canada", capital: "Ottawa", lat: 45.4, lon: -75.7 },
      { name: "Mexico", capital: "Mexico City", lat: 19.4, lon: -99.1 },
      { name: "Italy", capital: "Rome", lat: 41.9, lon: 12.5 },
      { name: "Spain", capital: "Madrid", lat: 40.4, lon: -3.7 },
      { name: "Egypt", capital: "Cairo", lat: 30.0, lon: 31.2 },
      { name: "South Africa", capital: "Pretoria", lat: -25.7, lon: 28.2 },
      { name: "Argentina", capital: "Buenos Aires", lat: -34.6, lon: -58.4 },
      { name: "South Korea", capital: "Seoul", lat: 37.6, lon: 127.0 },
      { name: "Turkey", capital: "Ankara", lat: 39.9, lon: 32.9 },
      { name: "Sweden", capital: "Stockholm", lat: 59.3, lon: 18.1 }
    ];

    const container = document.getElementById('globe-container');

    function getSize() {
      if (isFullscreen) {
        return { w: window.innerWidth, h: window.innerHeight };
      }
      return { w: container.clientWidth || window.innerWidth, h: 450 };
    }

    const { w: W, h: H } = getSize();
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, W / H, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(W, H);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // Handle resize in fullscreen mode
    if (isFullscreen) {
      window.addEventListener('resize', () => {
        const { w, h } = getSize();
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });
    }

    const earth = new THREE.Mesh(
      new THREE.SphereGeometry(2, 64, 64),
      new THREE.MeshPhongMaterial({
        map: new THREE.TextureLoader().load('https://unpkg.com/three-globe@2.31.0/example/img/earth-blue-marble.jpg'),
        bumpMap: new THREE.TextureLoader().load('https://unpkg.com/three-globe@2.31.0/example/img/earth-topology.png'),
        bumpScale: 0.05
      })
    );
    scene.add(earth);

    // Atmosphere glow
    scene.add(new THREE.Mesh(new THREE.SphereGeometry(2.1, 64, 64), new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.1, side: THREE.BackSide })));

    // Target reticle in front of globe - clean crosshair
    const targetGroup = new THREE.Group();
    const targetMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.9 });

    // Four straight lines with gap in center
    const lineLen = 0.15;
    const lineThick = 0.012;
    const gap = 0.06;

    const lineTop = new THREE.Mesh(new THREE.PlaneGeometry(lineThick, lineLen), targetMat);
    lineTop.position.set(0, gap + lineLen/2, 0);
    const lineBottom = new THREE.Mesh(new THREE.PlaneGeometry(lineThick, lineLen), targetMat);
    lineBottom.position.set(0, -gap - lineLen/2, 0);
    const lineLeft = new THREE.Mesh(new THREE.PlaneGeometry(lineLen, lineThick), targetMat);
    lineLeft.position.set(-gap - lineLen/2, 0, 0);
    const lineRight = new THREE.Mesh(new THREE.PlaneGeometry(lineLen, lineThick), targetMat);
    lineRight.position.set(gap + lineLen/2, 0, 0);

    targetGroup.add(lineTop, lineBottom, lineLeft, lineRight);

    // Center dot
    const dot = new THREE.Mesh(new THREE.CircleGeometry(0.015, 16), targetMat);
    targetGroup.add(dot);

    targetGroup.position.set(0, 0.15, 2.5);
    scene.add(targetGroup);

    // Lighting
    scene.add(new THREE.AmbientLight(0x404040));
    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(5, 3, 5);
    scene.add(sun);

    // Camera
    camera.position.set(0, 1, 6);
    camera.lookAt(0, 0, 0);

    // Country markers
    countries.forEach(c => {
      const phi = (90 - c.lat) * Math.PI / 180;
      const theta = (c.lon + 180) * Math.PI / 180;
      const r = 2.02;
      const m = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffcc00 }));
      m.position.set(-r * Math.sin(phi) * Math.cos(theta), r * Math.cos(phi), r * Math.sin(phi) * Math.sin(theta));
      m.userData = c;
      earth.add(m);
    });

    // Interaction state
    let auto = true, down = false, mx = 0, my = 0;
    let animatingToNorth = false;
    let targetQuaternion = null;
    const autoRotationSpeed = 0.003;

    // Weather state
    const APP_ID = 'globe-explorer';
    let currentCountry = null;
    let weatherCache = {};

    async function fetchWeather(capital) {
      if (weatherCache[capital]) {
        displayWeather(weatherCache[capital]);
        return;
      }
      try {
        const result = await widget.request(APP_ID, 'getWeather', { city: capital });
        if (result && !result.error) {
          weatherCache[capital] = result;
          displayWeather(result);
        }
      } catch (e) {
        console.error('Weather fetch failed:', e);
      }
    }

    function displayWeather(w) {
      document.getElementById('weather').innerHTML =
        '<span class="icon">' + w.icon + '</span>' +
        '<span class="temp">' + w.temp + '°</span>' +
        '<div class="desc">' + w.description + '</div>';
    }

    function clearWeather() {
      document.getElementById('weather').innerHTML = '';
    }

    function applyRotation(deltaX, deltaY) {
      const quaternionX = new THREE.Quaternion();
      const quaternionY = new THREE.Quaternion();
      quaternionY.setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * 0.005);
      quaternionX.setFromAxisAngle(new THREE.Vector3(1, 0, 0), deltaY * 0.005);
      earth.quaternion.premultiply(quaternionY);
      earth.quaternion.premultiply(quaternionX);
    }

    // Animate to north - keep current Y rotation, remove tilt
    document.getElementById('reset').addEventListener('click', () => {
      const euler = new THREE.Euler().setFromQuaternion(earth.quaternion, 'YXZ');
      targetQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, euler.y, 0, 'YXZ'));
      animatingToNorth = true;
    });

    renderer.domElement.addEventListener('mousedown', e => { down = true; mx = e.clientX; my = e.clientY; auto = false; animatingToNorth = false; });
    renderer.domElement.addEventListener('mouseup', () => { down = false; });
    renderer.domElement.addEventListener('mousemove', e => {
      if (down) {
        applyRotation(e.clientX - mx, e.clientY - my);
        mx = e.clientX;
        my = e.clientY;
      }
    });
    renderer.domElement.addEventListener('touchstart', e => { down = true; mx = e.touches[0].clientX; my = e.touches[0].clientY; auto = false; animatingToNorth = false; }, {passive:true});
    renderer.domElement.addEventListener('touchend', () => { down = false; });
    renderer.domElement.addEventListener('touchmove', e => {
      if (down) {
        applyRotation(e.touches[0].clientX - mx, e.touches[0].clientY - my);
        mx = e.touches[0].clientX;
        my = e.touches[0].clientY;
      }
    }, {passive:true});

    // Find country under the target (in front of globe, positive Z)
    function findCountry() {
      let best = null, minD = 999;
      earth.children.forEach(m => {
        if (m.userData && m.userData.name) {
          const p = new THREE.Vector3();
          m.getWorldPosition(p);
          if (p.z > 1.8) {
            const d = Math.sqrt(p.x * p.x + p.y * p.y);
            if (d < minD) { minD = d; best = m.userData; }
          }
        }
      });
      return best;
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      if (animatingToNorth && targetQuaternion) {
        earth.quaternion.slerp(targetQuaternion, 0.1);
        if (earth.quaternion.angleTo(targetQuaternion) < 0.001) {
          earth.quaternion.copy(targetQuaternion);
          animatingToNorth = false;
          targetQuaternion = null;
        }
      } else if (auto) {
        const autoQuat = new THREE.Quaternion();
        autoQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), autoRotationSpeed);
        earth.quaternion.premultiply(autoQuat);
      }

      const c = findCountry();
      if (c) {
        document.getElementById('info').innerHTML = '<strong>' + c.name + '</strong><br><span style="font-size:14px;opacity:0.8">' + c.capital + '</span>';
        if (currentCountry !== c.capital) {
          currentCountry = c.capital;
          fetchWeather(c.capital);
        }
      } else {
        document.getElementById('info').innerHTML = '';
        if (currentCountry !== null) {
          currentCountry = null;
          clearWeather();
        }
      }
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
